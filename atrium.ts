/**
 * MX API
 * The MX Atrium API supports over 48,000 data connections to thousands of financial institutions. It provides secure access to your users' accounts and transactions with industry-leading cleansing, categorization, and classification.  Atrium is designed according to resource-oriented REST architecture and responds with JSON bodies and HTTP response codes.  Use Atrium's development environment, vestibule.mx.com, to quickly get up and running. The development environment limits are 100 users, 25 members per user, and access to the top 15 institutions. Contact MX to purchase production access. 
 *
 * OpenAPI spec version: 0.1
 * 
 *
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://vestibule.mx.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class Account {
    'apr'?: number;
    'apy'?: number;
    'availableBalance'?: number;
    'availableCredit'?: number;
    'balance'?: number;
    'createdAt'?: string;
    'creditLimit'?: number;
    'currencyCode'?: string;
    'dayPaymentIsDue'?: number;
    'guid'?: string;
    'institutionCode'?: string;
    'interestRate'?: number;
    'isClosed'?: boolean;
    'lastPayment'?: number;
    'maturesOn'?: string;
    'memberGuid'?: string;
    'minimumBalance'?: number;
    'minimumPayment'?: number;
    'name'?: string;
    'originalBalance'?: number;
    'paymentDueAt'?: string;
    'payoffBalance'?: number;
    'startedOn'?: string;
    'subtype'?: string;
    'totalAccountValue'?: number;
    'type'?: string;
    'updatedAt'?: string;
    'userGuid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "apr",
            "baseName": "apr",
            "type": "number"
        },
        {
            "name": "apy",
            "baseName": "apy",
            "type": "number"
        },
        {
            "name": "availableBalance",
            "baseName": "available_balance",
            "type": "number"
        },
        {
            "name": "availableCredit",
            "baseName": "available_credit",
            "type": "number"
        },
        {
            "name": "balance",
            "baseName": "balance",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "creditLimit",
            "baseName": "credit_limit",
            "type": "number"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "dayPaymentIsDue",
            "baseName": "day_payment_is_due",
            "type": "number"
        },
        {
            "name": "guid",
            "baseName": "guid",
            "type": "string"
        },
        {
            "name": "institutionCode",
            "baseName": "institution_code",
            "type": "string"
        },
        {
            "name": "interestRate",
            "baseName": "interest_rate",
            "type": "number"
        },
        {
            "name": "isClosed",
            "baseName": "is_closed",
            "type": "boolean"
        },
        {
            "name": "lastPayment",
            "baseName": "last_payment",
            "type": "number"
        },
        {
            "name": "maturesOn",
            "baseName": "matures_on",
            "type": "string"
        },
        {
            "name": "memberGuid",
            "baseName": "member_guid",
            "type": "string"
        },
        {
            "name": "minimumBalance",
            "baseName": "minimum_balance",
            "type": "number"
        },
        {
            "name": "minimumPayment",
            "baseName": "minimum_payment",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "originalBalance",
            "baseName": "original_balance",
            "type": "number"
        },
        {
            "name": "paymentDueAt",
            "baseName": "payment_due_at",
            "type": "string"
        },
        {
            "name": "payoffBalance",
            "baseName": "payoff_balance",
            "type": "number"
        },
        {
            "name": "startedOn",
            "baseName": "started_on",
            "type": "string"
        },
        {
            "name": "subtype",
            "baseName": "subtype",
            "type": "string"
        },
        {
            "name": "totalAccountValue",
            "baseName": "total_account_value",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "userGuid",
            "baseName": "user_guid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Account.attributeTypeMap;
    }
}

export class AccountNumber {
    'accountGuid'?: string;
    'accountNumber'?: string;
    'memberGuid'?: string;
    'routingNumber'?: string;
    'userGuid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountGuid",
            "baseName": "account_guid",
            "type": "string"
        },
        {
            "name": "accountNumber",
            "baseName": "account_number",
            "type": "string"
        },
        {
            "name": "memberGuid",
            "baseName": "member_guid",
            "type": "string"
        },
        {
            "name": "routingNumber",
            "baseName": "routing_number",
            "type": "string"
        },
        {
            "name": "userGuid",
            "baseName": "user_guid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccountNumber.attributeTypeMap;
    }
}

export class AccountNumbersResponseBody {
    'accountNumbers'?: Array<AccountNumber>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountNumbers",
            "baseName": "account_numbers",
            "type": "Array<AccountNumber>"
        }    ];

    static getAttributeTypeMap() {
        return AccountNumbersResponseBody.attributeTypeMap;
    }
}

export class AccountOwner {
    'accountGuid'?: string;
    'address'?: string;
    'city'?: string;
    'country'?: string;
    'email'?: string;
    'guid'?: string;
    'memberGuid'?: string;
    'ownerName'?: string;
    'postalCode'?: string;
    'state'?: string;
    'userGuid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountGuid",
            "baseName": "account_guid",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "guid",
            "baseName": "guid",
            "type": "string"
        },
        {
            "name": "memberGuid",
            "baseName": "member_guid",
            "type": "string"
        },
        {
            "name": "ownerName",
            "baseName": "owner_name",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postal_code",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "userGuid",
            "baseName": "user_guid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccountOwner.attributeTypeMap;
    }
}

export class AccountOwnersResponseBody {
    'accountOwners'?: Array<AccountOwner>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountOwners",
            "baseName": "account_owners",
            "type": "Array<AccountOwner>"
        }    ];

    static getAttributeTypeMap() {
        return AccountOwnersResponseBody.attributeTypeMap;
    }
}

export class AccountResponseBody {
    'account'?: Account;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "account",
            "baseName": "account",
            "type": "Account"
        }    ];

    static getAttributeTypeMap() {
        return AccountResponseBody.attributeTypeMap;
    }
}

export class AccountsResponseBody {
    'accounts'?: Array<Account>;
    'pagination'?: Pagination;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accounts",
            "baseName": "accounts",
            "type": "Array<Account>"
        },
        {
            "name": "pagination",
            "baseName": "pagination",
            "type": "Pagination"
        }    ];

    static getAttributeTypeMap() {
        return AccountsResponseBody.attributeTypeMap;
    }
}

export class Challenge {
    'fieldName'?: string;
    'guid'?: string;
    'imageData'?: string;
    'label'?: string;
    'options'?: Array<ChallengeOption>;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fieldName",
            "baseName": "field_name",
            "type": "string"
        },
        {
            "name": "guid",
            "baseName": "guid",
            "type": "string"
        },
        {
            "name": "imageData",
            "baseName": "image_data",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<ChallengeOption>"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Challenge.attributeTypeMap;
    }
}

export class ChallengeOption {
    'imageData'?: string;
    'label'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "imageData",
            "baseName": "image_data",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChallengeOption.attributeTypeMap;
    }
}

export class ChallengesResponseBody {
    'challenges'?: Array<Challenge>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "challenges",
            "baseName": "challenges",
            "type": "Array<Challenge>"
        }    ];

    static getAttributeTypeMap() {
        return ChallengesResponseBody.attributeTypeMap;
    }
}

export class ConnectWidget {
    'connectWidgetUrl'?: string;
    'guid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connectWidgetUrl",
            "baseName": "connect_widget_url",
            "type": "string"
        },
        {
            "name": "guid",
            "baseName": "guid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConnectWidget.attributeTypeMap;
    }
}

export class ConnectWidgetRequestBody {
    'isMobileWebview'?: boolean;
    'currentInstitutionCode'?: string;
    'currentMemberGuid'?: string;
    'updateCredentials'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isMobileWebview",
            "baseName": "is_mobile_webview",
            "type": "boolean"
        },
        {
            "name": "currentInstitutionCode",
            "baseName": "current_institution_code",
            "type": "string"
        },
        {
            "name": "currentMemberGuid",
            "baseName": "current_member_guid",
            "type": "string"
        },
        {
            "name": "updateCredentials",
            "baseName": "update_credentials",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ConnectWidgetRequestBody.attributeTypeMap;
    }
}

export class ConnectWidgetResponseBody {
    'user'?: ConnectWidget;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "user",
            "baseName": "user",
            "type": "ConnectWidget"
        }    ];

    static getAttributeTypeMap() {
        return ConnectWidgetResponseBody.attributeTypeMap;
    }
}

export class CredentialOption {
    'label'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredentialOption.attributeTypeMap;
    }
}

export class CredentialRequest {
    'guid'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "guid",
            "baseName": "guid",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredentialRequest.attributeTypeMap;
    }
}

export class CredentialResponse {
    'fieldName'?: string;
    'guid'?: string;
    'label'?: string;
    'options'?: Array<CredentialOption>;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fieldName",
            "baseName": "field_name",
            "type": "string"
        },
        {
            "name": "guid",
            "baseName": "guid",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<CredentialOption>"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CredentialResponse.attributeTypeMap;
    }
}

export class CredentialsResponseBody {
    'credentials'?: Array<CredentialResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credentials",
            "baseName": "credentials",
            "type": "Array<CredentialResponse>"
        }    ];

    static getAttributeTypeMap() {
        return CredentialsResponseBody.attributeTypeMap;
    }
}

export class Institution {
    'code'?: string;
    'mediumLogoUrl'?: string;
    'name'?: string;
    'smallLogoUrl'?: string;
    'supportsAccountIdentification'?: boolean;
    'supportsAccountVerification'?: boolean;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "mediumLogoUrl",
            "baseName": "medium_logo_url",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "smallLogoUrl",
            "baseName": "small_logo_url",
            "type": "string"
        },
        {
            "name": "supportsAccountIdentification",
            "baseName": "supports_account_identification",
            "type": "boolean"
        },
        {
            "name": "supportsAccountVerification",
            "baseName": "supports_account_verification",
            "type": "boolean"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Institution.attributeTypeMap;
    }
}

export class InstitutionResponseBody {
    'institution'?: Institution;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "institution",
            "baseName": "institution",
            "type": "Institution"
        }    ];

    static getAttributeTypeMap() {
        return InstitutionResponseBody.attributeTypeMap;
    }
}

export class InstitutionsResponseBody {
    'institutions'?: Array<Institution>;
    'pagination'?: Pagination;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "institutions",
            "baseName": "institutions",
            "type": "Array<Institution>"
        },
        {
            "name": "pagination",
            "baseName": "pagination",
            "type": "Pagination"
        }    ];

    static getAttributeTypeMap() {
        return InstitutionsResponseBody.attributeTypeMap;
    }
}

export class Member {
    'aggregatedAt'?: string;
    'connectionStatus'?: string;
    'guid'?: boolean;
    'identifier'?: string;
    'institutionCode'?: string;
    'isBeingAggregated'?: boolean;
    'metadata'?: string;
    'name'?: string;
    'status'?: string;
    'successfullyAggregatedAt'?: string;
    'userGuid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aggregatedAt",
            "baseName": "aggregated_at",
            "type": "string"
        },
        {
            "name": "connectionStatus",
            "baseName": "connection_status",
            "type": "string"
        },
        {
            "name": "guid",
            "baseName": "guid",
            "type": "boolean"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "institutionCode",
            "baseName": "institution_code",
            "type": "string"
        },
        {
            "name": "isBeingAggregated",
            "baseName": "is_being_aggregated",
            "type": "boolean"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "successfullyAggregatedAt",
            "baseName": "successfully_aggregated_at",
            "type": "string"
        },
        {
            "name": "userGuid",
            "baseName": "user_guid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Member.attributeTypeMap;
    }
}

export class MemberConnectionStatus {
    'aggregatedAt'?: string;
    'challenges'?: Array<Challenge>;
    'connectionStatus'?: string;
    'guid'?: boolean;
    'hasProcessedAccounts'?: boolean;
    'hasProcessedTransactions'?: boolean;
    'isBeingAggregated'?: boolean;
    'status'?: string;
    'successfullyAggregatedAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aggregatedAt",
            "baseName": "aggregated_at",
            "type": "string"
        },
        {
            "name": "challenges",
            "baseName": "challenges",
            "type": "Array<Challenge>"
        },
        {
            "name": "connectionStatus",
            "baseName": "connection_status",
            "type": "string"
        },
        {
            "name": "guid",
            "baseName": "guid",
            "type": "boolean"
        },
        {
            "name": "hasProcessedAccounts",
            "baseName": "has_processed_accounts",
            "type": "boolean"
        },
        {
            "name": "hasProcessedTransactions",
            "baseName": "has_processed_transactions",
            "type": "boolean"
        },
        {
            "name": "isBeingAggregated",
            "baseName": "is_being_aggregated",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "successfullyAggregatedAt",
            "baseName": "successfully_aggregated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MemberConnectionStatus.attributeTypeMap;
    }
}

export class MemberConnectionStatusResponseBody {
    'member'?: MemberConnectionStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "member",
            "baseName": "member",
            "type": "MemberConnectionStatus"
        }    ];

    static getAttributeTypeMap() {
        return MemberConnectionStatusResponseBody.attributeTypeMap;
    }
}

export class MemberCreateRequest {
    'credentials': Array<CredentialRequest>;
    'identifier'?: string;
    'institutionCode': string;
    'metadata'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credentials",
            "baseName": "credentials",
            "type": "Array<CredentialRequest>"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "institutionCode",
            "baseName": "institution_code",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MemberCreateRequest.attributeTypeMap;
    }
}

export class MemberCreateRequestBody {
    'member'?: MemberCreateRequest;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "member",
            "baseName": "member",
            "type": "MemberCreateRequest"
        }    ];

    static getAttributeTypeMap() {
        return MemberCreateRequestBody.attributeTypeMap;
    }
}

export class MemberResponseBody {
    'member'?: Member;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "member",
            "baseName": "member",
            "type": "Member"
        }    ];

    static getAttributeTypeMap() {
        return MemberResponseBody.attributeTypeMap;
    }
}

export class MemberResumeRequest {
    'challenges'?: Array<CredentialRequest>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "challenges",
            "baseName": "challenges",
            "type": "Array<CredentialRequest>"
        }    ];

    static getAttributeTypeMap() {
        return MemberResumeRequest.attributeTypeMap;
    }
}

export class MemberResumeRequestBody {
    'member'?: MemberResumeRequest;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "member",
            "baseName": "member",
            "type": "MemberResumeRequest"
        }    ];

    static getAttributeTypeMap() {
        return MemberResumeRequestBody.attributeTypeMap;
    }
}

export class MemberUpdateRequest {
    'credentials'?: Array<CredentialRequest>;
    'identifier'?: string;
    'metadata'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "credentials",
            "baseName": "credentials",
            "type": "Array<CredentialRequest>"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MemberUpdateRequest.attributeTypeMap;
    }
}

export class MemberUpdateRequestBody {
    'member'?: MemberUpdateRequest;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "member",
            "baseName": "member",
            "type": "MemberUpdateRequest"
        }    ];

    static getAttributeTypeMap() {
        return MemberUpdateRequestBody.attributeTypeMap;
    }
}

export class MembersResponseBody {
    'members'?: Array<Member>;
    'pagination'?: Pagination;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "members",
            "baseName": "members",
            "type": "Array<Member>"
        },
        {
            "name": "pagination",
            "baseName": "pagination",
            "type": "Pagination"
        }    ];

    static getAttributeTypeMap() {
        return MembersResponseBody.attributeTypeMap;
    }
}

export class Merchant {
    'createdAt'?: string;
    'guid'?: string;
    'logoUrl'?: string;
    'name'?: string;
    'updatedAt'?: string;
    'websiteUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "guid",
            "baseName": "guid",
            "type": "string"
        },
        {
            "name": "logoUrl",
            "baseName": "logo_url",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "websiteUrl",
            "baseName": "website_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Merchant.attributeTypeMap;
    }
}

export class MerchantResponseBody {
    'merchant'?: Merchant;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchant",
            "baseName": "merchant",
            "type": "Merchant"
        }    ];

    static getAttributeTypeMap() {
        return MerchantResponseBody.attributeTypeMap;
    }
}

export class Pagination {
    'currentPage'?: number;
    'perPage'?: number;
    'totalEntries'?: number;
    'totalPages'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currentPage",
            "baseName": "current_page",
            "type": "number"
        },
        {
            "name": "perPage",
            "baseName": "per_page",
            "type": "number"
        },
        {
            "name": "totalEntries",
            "baseName": "total_entries",
            "type": "number"
        },
        {
            "name": "totalPages",
            "baseName": "total_pages",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Pagination.attributeTypeMap;
    }
}

export class Transaction {
    'accountGuid'?: string;
    'amount'?: number;
    'category'?: string;
    'checkNumber'?: number;
    'checkNumberString'?: string;
    'createdAt'?: string;
    'currencyCode'?: string;
    'date'?: string;
    'description'?: string;
    'guid'?: string;
    'isBillPay'?: boolean;
    'isDirectDeposit'?: boolean;
    'isExpense'?: boolean;
    'isFee'?: boolean;
    'isIncome'?: boolean;
    'isInternational'?: boolean;
    'isOverdraftFee'?: boolean;
    'isPayrollAdvance'?: boolean;
    'latitude'?: number;
    'longitude'?: number;
    'memberGuid'?: string;
    'memo'?: string;
    'merchantCategoryCode'?: number;
    'originalDescription'?: string;
    'postedAt'?: string;
    'status'?: string;
    'topLevelCategory'?: string;
    'transactedAt'?: string;
    'type'?: string;
    'updatedAt'?: string;
    'userGuid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountGuid",
            "baseName": "account_guid",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "checkNumber",
            "baseName": "check_number",
            "type": "number"
        },
        {
            "name": "checkNumberString",
            "baseName": "check_number_string",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currency_code",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "guid",
            "baseName": "guid",
            "type": "string"
        },
        {
            "name": "isBillPay",
            "baseName": "is_bill_pay",
            "type": "boolean"
        },
        {
            "name": "isDirectDeposit",
            "baseName": "is_direct_deposit",
            "type": "boolean"
        },
        {
            "name": "isExpense",
            "baseName": "is_expense",
            "type": "boolean"
        },
        {
            "name": "isFee",
            "baseName": "is_fee",
            "type": "boolean"
        },
        {
            "name": "isIncome",
            "baseName": "is_income",
            "type": "boolean"
        },
        {
            "name": "isInternational",
            "baseName": "is_international",
            "type": "boolean"
        },
        {
            "name": "isOverdraftFee",
            "baseName": "is_overdraft_fee",
            "type": "boolean"
        },
        {
            "name": "isPayrollAdvance",
            "baseName": "is_payroll_advance",
            "type": "boolean"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        },
        {
            "name": "memberGuid",
            "baseName": "member_guid",
            "type": "string"
        },
        {
            "name": "memo",
            "baseName": "memo",
            "type": "string"
        },
        {
            "name": "merchantCategoryCode",
            "baseName": "merchant_category_code",
            "type": "number"
        },
        {
            "name": "originalDescription",
            "baseName": "original_description",
            "type": "string"
        },
        {
            "name": "postedAt",
            "baseName": "posted_at",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "topLevelCategory",
            "baseName": "top_level_category",
            "type": "string"
        },
        {
            "name": "transactedAt",
            "baseName": "transacted_at",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "userGuid",
            "baseName": "user_guid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Transaction.attributeTypeMap;
    }
}

export class TransactionCleanseAndCategorizeRequest {
    'amount'?: number;
    'description'?: string;
    'identifier'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TransactionCleanseAndCategorizeRequest.attributeTypeMap;
    }
}

export class TransactionCleanseAndCategorizeResponse {
    'amount'?: number;
    'category'?: string;
    'description'?: string;
    'identifier'?: string;
    'type'?: string;
    'isBillPay'?: boolean;
    'isDirectDeposit'?: boolean;
    'isExpense'?: boolean;
    'isFee'?: boolean;
    'isIncome'?: boolean;
    'isInternational'?: boolean;
    'isOverdraftFee'?: boolean;
    'isPayrollAdvance'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "number"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "isBillPay",
            "baseName": "is_bill_pay",
            "type": "boolean"
        },
        {
            "name": "isDirectDeposit",
            "baseName": "is_direct_deposit",
            "type": "boolean"
        },
        {
            "name": "isExpense",
            "baseName": "is_expense",
            "type": "boolean"
        },
        {
            "name": "isFee",
            "baseName": "is_fee",
            "type": "boolean"
        },
        {
            "name": "isIncome",
            "baseName": "is_income",
            "type": "boolean"
        },
        {
            "name": "isInternational",
            "baseName": "is_international",
            "type": "boolean"
        },
        {
            "name": "isOverdraftFee",
            "baseName": "is_overdraft_fee",
            "type": "boolean"
        },
        {
            "name": "isPayrollAdvance",
            "baseName": "is_payroll_advance",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TransactionCleanseAndCategorizeResponse.attributeTypeMap;
    }
}

export class TransactionResponseBody {
    'transaction'?: Transaction;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transaction",
            "baseName": "transaction",
            "type": "Transaction"
        }    ];

    static getAttributeTypeMap() {
        return TransactionResponseBody.attributeTypeMap;
    }
}

export class TransactionsCleanseAndCategorizeRequestBody {
    'transactions'?: Array<TransactionCleanseAndCategorizeRequest>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactions",
            "baseName": "transactions",
            "type": "Array<TransactionCleanseAndCategorizeRequest>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionsCleanseAndCategorizeRequestBody.attributeTypeMap;
    }
}

export class TransactionsCleanseAndCategorizeResponseBody {
    'transactions'?: Array<TransactionCleanseAndCategorizeResponse>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactions",
            "baseName": "transactions",
            "type": "Array<TransactionCleanseAndCategorizeResponse>"
        }    ];

    static getAttributeTypeMap() {
        return TransactionsCleanseAndCategorizeResponseBody.attributeTypeMap;
    }
}

export class TransactionsResponseBody {
    'transactions'?: Array<Transaction>;
    'pagination'?: Pagination;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactions",
            "baseName": "transactions",
            "type": "Array<Transaction>"
        },
        {
            "name": "pagination",
            "baseName": "pagination",
            "type": "Pagination"
        }    ];

    static getAttributeTypeMap() {
        return TransactionsResponseBody.attributeTypeMap;
    }
}

export class User {
    'guid'?: string;
    'identifier'?: string;
    'isDisabled'?: boolean;
    'metadata'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "guid",
            "baseName": "guid",
            "type": "string"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "isDisabled",
            "baseName": "is_disabled",
            "type": "boolean"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

export class UserCreateRequestBody {
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return UserCreateRequestBody.attributeTypeMap;
    }
}

export class UserResponseBody {
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return UserResponseBody.attributeTypeMap;
    }
}

export class UserUpdateRequestBody {
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return UserUpdateRequestBody.attributeTypeMap;
    }
}

export class UsersResponseBody {
    'users'?: Array<User>;
    'pagination'?: Pagination;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "users",
            "baseName": "users",
            "type": "Array<User>"
        },
        {
            "name": "pagination",
            "baseName": "pagination",
            "type": "Pagination"
        }    ];

    static getAttributeTypeMap() {
        return UsersResponseBody.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
}

let typeMap: {[index: string]: any} = {
    "Account": Account,
    "AccountNumber": AccountNumber,
    "AccountNumbersResponseBody": AccountNumbersResponseBody,
    "AccountOwner": AccountOwner,
    "AccountOwnersResponseBody": AccountOwnersResponseBody,
    "AccountResponseBody": AccountResponseBody,
    "AccountsResponseBody": AccountsResponseBody,
    "Challenge": Challenge,
    "ChallengeOption": ChallengeOption,
    "ChallengesResponseBody": ChallengesResponseBody,
    "ConnectWidget": ConnectWidget,
    "ConnectWidgetRequestBody": ConnectWidgetRequestBody,
    "ConnectWidgetResponseBody": ConnectWidgetResponseBody,
    "CredentialOption": CredentialOption,
    "CredentialRequest": CredentialRequest,
    "CredentialResponse": CredentialResponse,
    "CredentialsResponseBody": CredentialsResponseBody,
    "Institution": Institution,
    "InstitutionResponseBody": InstitutionResponseBody,
    "InstitutionsResponseBody": InstitutionsResponseBody,
    "Member": Member,
    "MemberConnectionStatus": MemberConnectionStatus,
    "MemberConnectionStatusResponseBody": MemberConnectionStatusResponseBody,
    "MemberCreateRequest": MemberCreateRequest,
    "MemberCreateRequestBody": MemberCreateRequestBody,
    "MemberResponseBody": MemberResponseBody,
    "MemberResumeRequest": MemberResumeRequest,
    "MemberResumeRequestBody": MemberResumeRequestBody,
    "MemberUpdateRequest": MemberUpdateRequest,
    "MemberUpdateRequestBody": MemberUpdateRequestBody,
    "MembersResponseBody": MembersResponseBody,
    "Merchant": Merchant,
    "MerchantResponseBody": MerchantResponseBody,
    "Pagination": Pagination,
    "Transaction": Transaction,
    "TransactionCleanseAndCategorizeRequest": TransactionCleanseAndCategorizeRequest,
    "TransactionCleanseAndCategorizeResponse": TransactionCleanseAndCategorizeResponse,
    "TransactionResponseBody": TransactionResponseBody,
    "TransactionsCleanseAndCategorizeRequestBody": TransactionsCleanseAndCategorizeRequestBody,
    "TransactionsCleanseAndCategorizeResponseBody": TransactionsCleanseAndCategorizeResponseBody,
    "TransactionsResponseBody": TransactionsResponseBody,
    "User": User,
    "UserCreateRequestBody": UserCreateRequestBody,
    "UserResponseBody": UserResponseBody,
    "UserUpdateRequestBody": UserUpdateRequestBody,
    "UsersResponseBody": UsersResponseBody,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AccountsApiApiKeys {
    apiKey,
    clientID,
}

export class AccountsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'MX-API-Key'),
        'clientID': new ApiKeyAuth('header', 'MX-Client-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AccountsApiApiKeys, value: string) {
        (this.authentications as any)[AccountsApiApiKeys[key]].apiKey = value;
    }
    /**
     * This endpoint allows you to see every transaction that belongs to a specific account. The default from_date is 90 days prior to the request, and the default to_date is 5 days from the time of the request.<br> The from_date and to_date parameters can optionally be appended to the request. 
     * @summary List account transactions
     * @param accountGuid The unique identifier for an &#x60;account&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     * @param fromDate Filter transactions from this date.
     * @param toDate Filter transactions to this date.
     * @param page Specify current page.
     * @param recordsPerPage Specify records per page.
     */
    public listAccountTransactions (accountGuid: string, userGuid: string, fromDate?: string, toDate?: string, page?: number, recordsPerPage?: number) : Promise<{ response: http.IncomingMessage; body: TransactionsResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/accounts/{account_guid}/transactions'
            .replace('{' + 'account_guid' + '}', encodeURIComponent(String(accountGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountGuid' is not null or undefined
        if (accountGuid === null || accountGuid === undefined) {
            throw new Error('Required parameter accountGuid was null or undefined when calling listAccountTransactions.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling listAccountTransactions.');
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['from_date'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['to_date'] = ObjectSerializer.serialize(toDate, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (recordsPerPage !== undefined) {
            localVarQueryParameters['records_per_page'] = ObjectSerializer.serialize(recordsPerPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionsResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionsResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Use this endpoint to view information about every account that belongs to a user. You'll need the user's GUID to access this list. The information will include the account type  e.g., CHECKING, MONEY_MARKET, or PROPERTY  the account balance, the date the account was started, etc.
     * @summary List accounts for a user
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     * @param page Specify current page.
     * @param recordsPerPage Specify records per page.
     */
    public listUserAccounts (userGuid: string, page?: number, recordsPerPage?: number) : Promise<{ response: http.IncomingMessage; body: AccountsResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/accounts'
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling listUserAccounts.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (recordsPerPage !== undefined) {
            localVarQueryParameters['records_per_page'] = ObjectSerializer.serialize(recordsPerPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountsResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountsResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Reading an account allows you to get information about a specific account that belongs to a user. That includes the account type  e.g., CHECKING, MONEY_MARKET, or PROPERTY  the balance, the date the account was started, and much more.<br> There are two endpoints for reading an account. Both will return the same information.<br> It's important to remember that balance and available_balance will normally be positive numbers  for all account types. But this should be interpreted differently for debt accounts and asset accounts.<br> An asset account, e.g., CHECKING, SAVINGS, or INVESTMENT, will have a positive balance unless it is in an overdraft condition, in which case the balance will be negative.<br> On the other hand, a debt account, e.g., CREDIT CARD, LOAN, MORTGAGE, would have a positivebalance when the user owes money on the account. It would have a negative balance if the account has been overpaid. 
     * @summary Read an account
     * @param accountGuid The unique identifier for an &#x60;account&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public readAccount (accountGuid: string, userGuid: string) : Promise<{ response: http.IncomingMessage; body: AccountResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/accounts/{account_guid}'
            .replace('{' + 'account_guid' + '}', encodeURIComponent(String(accountGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountGuid' is not null or undefined
        if (accountGuid === null || accountGuid === undefined) {
            throw new Error('Required parameter accountGuid was null or undefined when calling readAccount.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling readAccount.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Reading an account allows you to get information about a specific account that belongs to a user. That includes the account type  e.g., CHECKING, MONEY_MARKET, or PROPERTY  the balance, the date the account was started, and much more.<br> There are two endpoints for reading an account. Both will return the same information.<br> It's important to remember that balance and available_balance will normally be positive numbers  for all account types. But this should be interpreted differently for debt accounts and asset accounts.<br> An asset account, e.g., CHECKING, SAVINGS, or INVESTMENT, will have a positive balance unless it is in an overdraft condition, in which case the balance will be negative.<br> On the other hand, a debt account, e.g., CREDIT CARD, LOAN, MORTGAGE, would have a positivebalance when the user owes money on the account. It would have a negative balance if the account has been overpaid. 
     * @summary Read an account
     * @param accountGuid The unique identifier for an &#x60;account&#x60;.
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public readAccountByMemberGUID (accountGuid: string, memberGuid: string, userGuid: string) : Promise<{ response: http.IncomingMessage; body: AccountResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}/accounts/{account_guid}'
            .replace('{' + 'account_guid' + '}', encodeURIComponent(String(accountGuid)))
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountGuid' is not null or undefined
        if (accountGuid === null || accountGuid === undefined) {
            throw new Error('Required parameter accountGuid was null or undefined when calling readAccountByMemberGUID.');
        }

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling readAccountByMemberGUID.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling readAccountByMemberGUID.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ConnectWidgetApiApiKeys {
    apiKey,
    clientID,
}

export class ConnectWidgetApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'MX-API-Key'),
        'clientID': new ApiKeyAuth('header', 'MX-Client-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ConnectWidgetApiApiKeys, value: string) {
        (this.authentications as any)[ConnectWidgetApiApiKeys[key]].apiKey = value;
    }
    /**
     * This endpoint will return a URL for an embeddable version of MX Connect.
     * @summary Embedding in a website
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     * @param body Optional config options for WebView (is_mobile_webview, current_institution_code, current_member_guid, update_credentials)
     */
    public getConnectWidget (userGuid: string, body: ConnectWidgetRequestBody) : Promise<{ response: http.IncomingMessage; body: ConnectWidgetResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/connect_widget_url'
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling getConnectWidget.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling getConnectWidget.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ConnectWidgetRequestBody")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConnectWidgetResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConnectWidgetResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IdentityApiApiKeys {
    apiKey,
    clientID,
}

export class IdentityApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'MX-API-Key'),
        'clientID': new ApiKeyAuth('header', 'MX-Client-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: IdentityApiApiKeys, value: string) {
        (this.authentications as any)[IdentityApiApiKeys[key]].apiKey = value;
    }
    /**
     * The identify endpoint begins an identification process for an already-existing member.
     * @summary Identify
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public identifyMember (memberGuid: string, userGuid: string) : Promise<{ response: http.IncomingMessage; body: MemberResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}/identify'
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling identifyMember.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling identifyMember.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MemberResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MemberResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint returns an array with information about every account associated with a particular member.
     * @summary List member account owners
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public listAccountOwners (memberGuid: string, userGuid: string) : Promise<{ response: http.IncomingMessage; body: AccountOwnersResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}/account_owners'
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling listAccountOwners.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling listAccountOwners.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountOwnersResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountOwnersResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InstitutionsApiApiKeys {
    apiKey,
    clientID,
}

export class InstitutionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'MX-API-Key'),
        'clientID': new ApiKeyAuth('header', 'MX-Client-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InstitutionsApiApiKeys, value: string) {
        (this.authentications as any)[InstitutionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * This endpoint allows you to see what institutions are available for connection. Information returned will include the institution_code assigned to a particular institution, URLs for the financial institution's logo, and the URL for its website.<br> This endpoint takes an optional query string, name={string}. This will list only institutions in which the appended string appears. 
     * @summary List institutions
     * @param name This will list only institutions in which the appended string appears.
     * @param page Specify current page.
     * @param recordsPerPage Specify records per page.
     */
    public listInstitutions (name?: string, page?: number, recordsPerPage?: number) : Promise<{ response: http.IncomingMessage; body: InstitutionsResponseBody;  }> {
        const localVarPath = this.basePath + '/institutions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (recordsPerPage !== undefined) {
            localVarQueryParameters['records_per_page'] = ObjectSerializer.serialize(recordsPerPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: InstitutionsResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InstitutionsResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint allows you to see information for a specific institution.
     * @summary Read institution
     * @param institutionCode The institution_code of the institution.
     */
    public readInstitution (institutionCode: string) : Promise<{ response: http.IncomingMessage; body: InstitutionResponseBody;  }> {
        const localVarPath = this.basePath + '/institutions/{institution_code}'
            .replace('{' + 'institution_code' + '}', encodeURIComponent(String(institutionCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'institutionCode' is not null or undefined
        if (institutionCode === null || institutionCode === undefined) {
            throw new Error('Required parameter institutionCode was null or undefined when calling readInstitution.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: InstitutionResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InstitutionResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Use this endpoint to see which credentials will be needed to create a member for a specific institution.
     * @summary Read institution credentials
     * @param institutionCode The institution_code of the institution.
     */
    public readInstitutionCredentials (institutionCode: string) : Promise<{ response: http.IncomingMessage; body: CredentialsResponseBody;  }> {
        const localVarPath = this.basePath + '/institutions/{institution_code}/credentials'
            .replace('{' + 'institution_code' + '}', encodeURIComponent(String(institutionCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'institutionCode' is not null or undefined
        if (institutionCode === null || institutionCode === undefined) {
            throw new Error('Required parameter institutionCode was null or undefined when calling readInstitutionCredentials.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CredentialsResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CredentialsResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MembersApiApiKeys {
    apiKey,
    clientID,
}

export class MembersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'MX-API-Key'),
        'clientID': new ApiKeyAuth('header', 'MX-Client-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MembersApiApiKeys, value: string) {
        (this.authentications as any)[MembersApiApiKeys[key]].apiKey = value;
    }
    /**
     * Calling this endpoint initiates an aggregation event for the member. This brings in the latest account and transaction data from the connected institution. If this data has recently been updated, MX may not initiate an aggregation event. 
     * @summary Aggregate member
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public aggregateMember (memberGuid: string, userGuid: string) : Promise<{ response: http.IncomingMessage; body: MemberResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}/aggregate'
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling aggregateMember.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling aggregateMember.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MemberResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MemberResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint allows you to create a new member. Members are created with the required parameters credentials and institution_code, and the optional parameters identifier and metadata.<br> When creating a member, you'll need to include the correct type of credential required by the financial institution and provided by the user. You can find out which credential type is required with the /institutions/{institution_code}/credentials endpoint.<br> If successful, Atrium will respond with the newly-created member object.<br> Once you successfully create a member, MX will immediately validate the provided credentials and attempt to aggregate data for accounts and transactions. 
     * @summary Create member
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     * @param body Member object to be created with optional parameters (identifier and metadata) and required parameters (credentials and institution_code)
     */
    public createMember (userGuid: string, body: MemberCreateRequestBody) : Promise<{ response: http.IncomingMessage; body: MemberResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members'
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling createMember.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createMember.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MemberCreateRequestBody")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MemberResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MemberResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Accessing this endpoint will permanently delete a member.
     * @summary Delete member
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public deleteMember (memberGuid: string, userGuid: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}'
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling deleteMember.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling deleteMember.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint returns an array with information about every account associated with a particular member.
     * @summary List member accounts
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     * @param page Specify current page.
     * @param recordsPerPage Specify records per page.
     */
    public listMemberAccounts (memberGuid: string, userGuid: string, page?: number, recordsPerPage?: number) : Promise<{ response: http.IncomingMessage; body: AccountsResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}/accounts'
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling listMemberAccounts.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling listMemberAccounts.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (recordsPerPage !== undefined) {
            localVarQueryParameters['records_per_page'] = ObjectSerializer.serialize(recordsPerPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountsResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountsResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint returns an array which contains information on every non-MFA credential associated with a specific member.
     * @summary List member credentials
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public listMemberCredentials (memberGuid: string, userGuid: string) : Promise<{ response: http.IncomingMessage; body: CredentialsResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}/credentials'
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling listMemberCredentials.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling listMemberCredentials.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CredentialsResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CredentialsResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Use this endpoint for information on what multi-factor authentication challenges need to be answered in order to aggregate a member.<br> If the aggregation is not challenged, i.e., the member does not have a connection status of CHALLENGED, then code 204 No Content will be returned.<br> If the aggregation has been challenged, i.e., the member does have a connection status of CHALLENGED, then code 200 OK will be returned  along with the corresponding credentials. 
     * @summary List member MFA challenges
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public listMemberMFAChallenges (memberGuid: string, userGuid: string) : Promise<{ response: http.IncomingMessage; body: ChallengesResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}/challenges'
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling listMemberMFAChallenges.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling listMemberMFAChallenges.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ChallengesResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChallengesResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Use this endpoint to get all transactions from all accounts associated with a specific member.<br> This endpoint accepts optional URL query parameters  from_date and to_date  which are used to filter transactions according to the date they were posted. If no values are given for the query parameters, from_date will default to 90 days prior to the request and to_date will default to 5 days from the time of the request. 
     * @summary List member transactions
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     * @param fromDate Filter transactions from this date.
     * @param toDate Filter transactions to this date.
     * @param page Specify current page.
     * @param recordsPerPage Specify records per page.
     */
    public listMemberTransactions (memberGuid: string, userGuid: string, fromDate?: string, toDate?: string, page?: number, recordsPerPage?: number) : Promise<{ response: http.IncomingMessage; body: TransactionsResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}/transactions'
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling listMemberTransactions.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling listMemberTransactions.');
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['from_date'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['to_date'] = ObjectSerializer.serialize(toDate, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (recordsPerPage !== undefined) {
            localVarQueryParameters['records_per_page'] = ObjectSerializer.serialize(recordsPerPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionsResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionsResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint returns an array which contains information on every member associated with a specific user.
     * @summary List members
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     * @param page Specify current page.
     * @param recordsPerPage Specify records per page.
     */
    public listMembers (userGuid: string, page?: number, recordsPerPage?: number) : Promise<{ response: http.IncomingMessage; body: MembersResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members'
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling listMembers.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (recordsPerPage !== undefined) {
            localVarQueryParameters['records_per_page'] = ObjectSerializer.serialize(recordsPerPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MembersResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MembersResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Use this endpoint to read the attributes of a specific member.
     * @summary Read member
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public readMember (memberGuid: string, userGuid: string) : Promise<{ response: http.IncomingMessage; body: MemberResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}'
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling readMember.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling readMember.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MemberResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MemberResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint provides the status of the member's most recent aggregation event. This is an important step in the aggregation process, and the results returned by this endpoint should determine what you do next in order to successfully aggregate a member.<br> MX has introduced new, more detailed information on the current status of a member's connection to a financial institution and the state of its aggregation: the connection_status field. These are intended to replace and expand upon the information provided in the status field, which will soon be deprecated; support for the status field remains for the time being. 
     * @summary Read member connection status
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public readMemberStatus (memberGuid: string, userGuid: string) : Promise<{ response: http.IncomingMessage; body: MemberConnectionStatusResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}/status'
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling readMemberStatus.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling readMemberStatus.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MemberConnectionStatusResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MemberConnectionStatusResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint answers the challenges needed when a member has been challenged by multi-factor authentication.
     * @summary Resume aggregation from MFA
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     * @param body Member object with MFA challenge answers
     */
    public resumeMember (memberGuid: string, userGuid: string, body: MemberResumeRequestBody) : Promise<{ response: http.IncomingMessage; body: MemberResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}/resume'
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling resumeMember.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling resumeMember.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling resumeMember.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MemberResumeRequestBody")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MemberResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MemberResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Use this endpoint to update a member's attributes. Only the credentials, identifier, and metadata parameters can be updated. To get a list of the required credentials for the member, use the list member credentials endpoint. 
     * @summary Update member
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     * @param body Member object to be updated with optional parameters (credentials, identifier, metadata)
     */
    public updateMember (memberGuid: string, userGuid: string, body?: MemberUpdateRequestBody) : Promise<{ response: http.IncomingMessage; body: MemberResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}'
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling updateMember.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling updateMember.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MemberUpdateRequestBody")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MemberResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MemberResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MerchantsApiApiKeys {
    apiKey,
    clientID,
}

export class MerchantsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'MX-API-Key'),
        'clientID': new ApiKeyAuth('header', 'MX-Client-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MerchantsApiApiKeys, value: string) {
        (this.authentications as any)[MerchantsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns information about a particular merchant, such as a logo, name, and website.
     * @summary Read merchant
     * @param merchantGuid The unique identifier for a &#x60;merchant&#x60;.
     */
    public readMerchant (merchantGuid: string) : Promise<{ response: http.IncomingMessage; body: MerchantResponseBody;  }> {
        const localVarPath = this.basePath + '/merchants/{merchant_guid}'
            .replace('{' + 'merchant_guid' + '}', encodeURIComponent(String(merchantGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'merchantGuid' is not null or undefined
        if (merchantGuid === null || merchantGuid === undefined) {
            throw new Error('Required parameter merchantGuid was null or undefined when calling readMerchant.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MerchantResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MerchantResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionsApiApiKeys {
    apiKey,
    clientID,
}

export class TransactionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'MX-API-Key'),
        'clientID': new ApiKeyAuth('header', 'MX-Client-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionsApiApiKeys, value: string) {
        (this.authentications as any)[TransactionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Use this endpoint to categorize, cleanse, and classify transactions. These transactions are not persisted or stored on the MX platform.
     * @summary Categorize transactions
     * @param body User object to be created with optional parameters (amount, type) amd required parameters (description, identifier)
     */
    public cleanseAndCategorizeTransactions (body: TransactionsCleanseAndCategorizeRequestBody) : Promise<{ response: http.IncomingMessage; body: TransactionsCleanseAndCategorizeResponseBody;  }> {
        const localVarPath = this.basePath + '/cleanse_and_categorize';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling cleanseAndCategorizeTransactions.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TransactionsCleanseAndCategorizeRequestBody")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionsCleanseAndCategorizeResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionsCleanseAndCategorizeResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Use this endpoint to get all transactions that belong to a specific user, across all the user's members and accounts.<br> This endpoint accepts optional query parameters, from_date and to_date, which filter transactions according to the date they were posted. If no values are given, from_date will default to 90 days prior to the request, and to_date will default to 5 days from the time of the request. 
     * @summary List transactions for a user
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     * @param page Specify current page.
     * @param fromDate Filter transactions from this date.
     * @param recordsPerPage Specify records per page.
     * @param toDate Filter transactions to this date.
     */
    public listUserTransactions (userGuid: string, page?: number, fromDate?: string, recordsPerPage?: number, toDate?: string) : Promise<{ response: http.IncomingMessage; body: TransactionsResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/transactions'
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling listUserTransactions.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['from_date'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (recordsPerPage !== undefined) {
            localVarQueryParameters['records_per_page'] = ObjectSerializer.serialize(recordsPerPage, "number");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['to_date'] = ObjectSerializer.serialize(toDate, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionsResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionsResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This endpoint allows you to view information about a specific transaction that belongs to a user.<br>
     * @summary Read a transaction
     * @param transactionGuid The unique identifier for a &#x60;transaction&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public readTransaction (transactionGuid: string, userGuid: string) : Promise<{ response: http.IncomingMessage; body: TransactionResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/transactions/{transaction_guid}'
            .replace('{' + 'transaction_guid' + '}', encodeURIComponent(String(transactionGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transactionGuid' is not null or undefined
        if (transactionGuid === null || transactionGuid === undefined) {
            throw new Error('Required parameter transactionGuid was null or undefined when calling readTransaction.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling readTransaction.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TransactionResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TransactionResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
    apiKey,
    clientID,
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'MX-API-Key'),
        'clientID': new ApiKeyAuth('header', 'MX-Client-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }
    /**
     * Call this endpoint to create a new user. Atrium will respond with the newly-created user object if successful. This endpoint accepts several parameters: identifier, metadata, and is_disabled.<br> Disabling a user means that accounts and transactions associated with it will not be updated in the background by MX. It will also restrict access to that user's data until they are no longer disabled. Users who are disabled for the entirety of an Atrium billing period will not be factored into that month's bill. 
     * @summary Create user
     * @param body User object to be created with optional parameters (identifier, is_disabled, metadata)
     */
    public createUser (body: UserCreateRequestBody) : Promise<{ response: http.IncomingMessage; body: UserResponseBody;  }> {
        const localVarPath = this.basePath + '/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserCreateRequestBody")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calling this endpoint will permanently delete a user from Atrium. If successful, the API will respond with Status: 204 No Content. 
     * @summary Delete user
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public deleteUser (userGuid: string) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}'
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling deleteUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Use this endpoint to list every user you've created in Atrium.
     * @summary List users
     * @param page Specify current page.
     * @param recordsPerPage Specify records per page.
     */
    public listUsers (page?: number, recordsPerPage?: number) : Promise<{ response: http.IncomingMessage; body: UsersResponseBody;  }> {
        const localVarPath = this.basePath + '/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (recordsPerPage !== undefined) {
            localVarQueryParameters['records_per_page'] = ObjectSerializer.serialize(recordsPerPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UsersResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UsersResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Use this endpoint to read the attributes of a specific user.
     * @summary Read user
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public readUser (userGuid: string) : Promise<{ response: http.IncomingMessage; body: UserResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}'
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling readUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Use this endpoint to update the attributes of a specific user. Atrium will respond with the updated user object.<br> Disabling a user means that accounts and transactions associated with it will not be updated in the background by MX. It will also restrict access to that user's data until they are no longer disabled. Users who are disabled for the entirety of an Atrium billing period will not be factored into that month's bill.<br> To disable a user, update it and set the is_disabled parameter to true. Set it to false to re-enable the user. 
     * @summary Update user
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     * @param body User object to be updated with optional parameters (identifier, is_disabled, metadata)
     */
    public updateUser (userGuid: string, body?: UserUpdateRequestBody) : Promise<{ response: http.IncomingMessage; body: UserResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}'
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling updateUser.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserUpdateRequestBody")
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VerificationApiApiKeys {
    apiKey,
    clientID,
}

export class VerificationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'apiKey': new ApiKeyAuth('header', 'MX-API-Key'),
        'clientID': new ApiKeyAuth('header', 'MX-Client-ID'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VerificationApiApiKeys, value: string) {
        (this.authentications as any)[VerificationApiApiKeys[key]].apiKey = value;
    }
    /**
     * Use this endpoint to check whether account and routing numbers are available for accounts associated with a particular member. It returns the account_numbers object, which contains account and routing number data for each account associated with the member.
     * @summary Read account numbers
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public listAccountNumbers (memberGuid: string, userGuid: string) : Promise<{ response: http.IncomingMessage; body: AccountNumbersResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}/account_numbers'
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling listAccountNumbers.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling listAccountNumbers.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountNumbersResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountNumbersResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Use this endpoint to check whether account and routing numbers are available for a specific account. It returns the account_numbers object, which contains account and routing number data.
     * @summary Read account numbers by account GUID
     * @param accountGuid The unique identifier for an &#x60;account&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public listAccountNumbersByAccount (accountGuid: string, userGuid: string) : Promise<{ response: http.IncomingMessage; body: AccountNumbersResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/accounts/{account_guid}/account_numbers'
            .replace('{' + 'account_guid' + '}', encodeURIComponent(String(accountGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'accountGuid' is not null or undefined
        if (accountGuid === null || accountGuid === undefined) {
            throw new Error('Required parameter accountGuid was null or undefined when calling listAccountNumbersByAccount.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling listAccountNumbersByAccount.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccountNumbersResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccountNumbersResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The verify endpoint begins a verification process for a member.
     * @summary Verify
     * @param memberGuid The unique identifier for a &#x60;member&#x60;.
     * @param userGuid The unique identifier for a &#x60;user&#x60;.
     */
    public verifyMember (memberGuid: string, userGuid: string) : Promise<{ response: http.IncomingMessage; body: MemberResponseBody;  }> {
        const localVarPath = this.basePath + '/users/{user_guid}/members/{member_guid}/verify'
            .replace('{' + 'member_guid' + '}', encodeURIComponent(String(memberGuid)))
            .replace('{' + 'user_guid' + '}', encodeURIComponent(String(userGuid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'memberGuid' is not null or undefined
        if (memberGuid === null || memberGuid === undefined) {
            throw new Error('Required parameter memberGuid was null or undefined when calling verifyMember.');
        }

        // verify required parameter 'userGuid' is not null or undefined
        if (userGuid === null || userGuid === undefined) {
            throw new Error('Required parameter userGuid was null or undefined when calling verifyMember.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKey.applyToRequest(localVarRequestOptions);

        this.authentications.clientID.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MemberResponseBody;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MemberResponseBody");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}

export class AtriumClient {
    constructor(apiKey, clientID) { 
        this.mount('accounts', new AccountsApi(), apiKey, clientID);
        this.mount('connectWidget', new ConnectWidgetApi(), apiKey, clientID);
        this.mount('identity', new IdentityApi(), apiKey, clientID);
        this.mount('institutions', new InstitutionsApi(), apiKey, clientID);
        this.mount('members', new MembersApi(), apiKey, clientID);
        this.mount('merchants', new MerchantsApi(), apiKey, clientID);
        this.mount('transactions', new TransactionsApi(), apiKey, clientID);
        this.mount('users', new UsersApi(), apiKey, clientID);
        this.mount('verification', new VerificationApi(), apiKey, clientID);
    }

    mount(label, val, apiKey, clientID) {
        val.setApiKey(0, apiKey);
        val.setApiKey(1, clientID);
        this[label] = val;
    }
}
